{"version":3,"sources":["../../src/bin/index.ts","../../../parser/src/parser.ts","../../../parser/src/index.ts","../../src/index.ts","../../src/args/args.ts","../../src/args/keys.ts","../../src/args/getValidatedArgs.ts"],"sourcesContent":["#! /usr/bin/env node\nimport \"source-map-support/register\";\n\nimport Debug from \"debug\";\nimport fs from \"fs\";\nimport { pwcScanner } from \"..\";\nimport { args, getValidatedArgs } from \"../args\";\n\nconst debug = Debug(\"pwc-scanner:cli\");\n\n(async function runScript() {\n  const { outFile, project, grep, grepInvert, config } = getValidatedArgs();\n\n  debug(\"cli args: %o\", args);\n\n  const { result, execaResult } = await pwcScanner({\n    project,\n    grep: grep ?? null,\n    grepInvert: grepInvert ?? null,\n    config,\n  });\n\n  process.stdout.write(execaResult.stdout + \"\\n\");\n\n  debug(\"result: %o\", result);\n\n  if (result) {\n    fs.writeFileSync(outFile, JSON.stringify(result));\n    debug(\"result was written to: %s\", outFile);\n  }\n\n  process.exit(execaResult.exitCode);\n})();\n","export type TestSuite = {\n  [x: string]: Record<string, string[]>;\n};\n\nexport const parse = (inputString: string): TestSuite => {\n  const lines = inputString.split(\"\\n\");\n  const result: TestSuite = {};\n\n  for (const line of lines) {\n    const match = line.match(/\\[([^\\]]+)\\] › ([^:]+):(\\d+:\\d+) › (.+)/);\n    if (match) {\n      const [_, project, spec, lineNum, testName] = match;\n      if (!result[project]) {\n        result[project] = {};\n      }\n      if (!result[project][spec]) {\n        result[project][spec] = [];\n      }\n\n      result[project][spec].push(testName);\n    }\n  }\n\n  return result;\n};\n","import { parse } from \"./parser\";\n\nexport function parseTestSuite(input: string, playwrightVersion?: string) {\n  return parse(input);\n}\n\nexport { type TestSuite } from \"./parser\";\n","import { parseTestSuite } from \"@currents/pwc-parser\";\nimport Debug from \"debug\";\n\nconst debug = Debug(\"pwc-scanner\");\n\nexport const pwcScanner = async (params: {\n  project?: string;\n  grep: string | null;\n  grepInvert: string | null;\n  config?: string;\n}) => {\n  // https://github.com/microsoft/TypeScript/issues/43329\n  // @ts-ignore\n  const { execa } = (await eval('import(\"execa\")')) as Promise<\n    typeof import(\"execa\")\n  >;\n\n  const cliParams = [\n    \"test\",\n    \"--list\",\n    ...Object.entries(params)\n      .filter(([_, value]) => value !== undefined)\n      .map(([key, value]) => `${toCliParam(key)}=${value}`),\n    \"--reporter=list\", // do not use any configuration reporters\n    \"--shard=1/1\", // override the option that was potentially set in the configuration file\n  ];\n\n  debug(\"running playwright with the following params: %o\", cliParams);\n\n  const execaResult = await execa(\"playwright\", cliParams, {\n    env: {\n      PWTEST_WATCH: undefined, // no don use if passed\n    },\n  });\n\n  debug(\"execa result: %o\", execaResult);\n\n  if (execaResult.failed) {\n    return { execaResult, result: null };\n  }\n\n  return { execaResult, result: parseTestSuite(execaResult.stdout) };\n};\n\nconst toCliParam = (param: string) => {\n  switch (param) {\n    case \"project\":\n      return \"--project\";\n    case \"grep\":\n      return \"--grep\";\n    case \"grepInvert\":\n      return \"--grep-invert\";\n    case \"config\":\n      return \"--config\";\n    default:\n      throw new Error(\"Invalid param\");\n  }\n};\n","import arg from \"arg\";\nimport { keys } from \"./keys\";\n\nexport const args = arg(\n  {\n    // Types\n    [keys.config]: String,\n    [keys.grep]: String,\n    [keys.grepInvert]: String,\n    [keys.project]: String,\n    [keys.outFile]: String,\n\n    // Aliases\n    [keys.c]: keys.config,\n    [keys.g]: keys.grep,\n  },\n  { permissive: true }\n);\n","export const keys = {\n  config: \"--config\",\n  grep: \"--grep\",\n  grepInvert: \"--grep-invert\",\n  project: \"--project\",\n  inspect: \"--inspect\",\n  outFile: \"--out-file\",\n  c: \"-c\",\n  g: \"-g\",\n} as const;\n","import { args } from \"./args\";\nimport { keys } from \"./keys\";\n\nexport function getValidatedArgs() {\n  const outFile =\n    keys.outFile in args ? args[keys.outFile] : \"./pwc-scanner-output.json\";\n\n  if (!outFile) {\n    const errorString = \"--out-file is not set\";\n    throw new Error(errorString);\n  }\n\n  const grep =\n    keys.grep in args\n      ? args[keys.grep]\n      : keys.g in args\n      ? args[keys.g]\n      : undefined;\n\n  const config =\n    keys.config in args\n      ? args[keys.config]\n      : keys.c in args\n      ? args[keys.c]\n      : undefined;\n\n  return {\n    project: args[\"--project\"],\n    grepInvert: args[\"--grep-invert\"],\n    grep,\n    config,\n    outFile,\n  };\n}\n"],"mappings":"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","names":["import_register","import_debug","import_fs","parse","inputString","lines","result","line","match","_","project","spec","lineNum","testName","parseTestSuite","input","playwrightVersion","parse","import_debug","debug","Debug","pwcScanner","_","value","key","toCliParam","parseTestSuite","param","import_arg","keys","args","arg","keys","getValidatedArgs","outFile","keys","args","errorString","grep","config","debug","Debug","outFile","project","grep","grepInvert","config","getValidatedArgs","args","result","execaResult","pwcScanner","fs"]}